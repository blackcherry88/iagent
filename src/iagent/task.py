"""Fill in a module description here"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/010_task.ipynb.

# %% auto 0
__all__ = ["TaskStatus", "TaskEvent", "TaskListener", "Task"]

# %% ../../nbs/010_task.ipynb 4
import uuid
from enum import Enum
from typing import List, Optional, Union

from pydantic import BaseModel, Field

from .core import FunctionInput, FunctionResult


class TaskStatus(str, Enum):
    PENDING = "pending"
    STARTING = "starting"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"


class TaskEvent(str, Enum):
    STARTING = "starting"
    COMPLETED = "completed"
    FAILED = "failed"
    RUNNING = "running"
    SUB_TASK_ADDED = "sub_task_added"
    SUB_TASK_REMOVED = "sub_task_removed"


class TaskListener:
    """
    Listener interface for Task events.
    Implement on_event to handle task events.
    """

    def on_event(self, task: "Task", event: TaskEvent, **kwargs):
        pass


class Task(BaseModel):
    """
    Task is a self-contain work unit i.e. doesn't depend on further context,
    But could have a list of sub tasks
    """

    id: str = Field(..., description="Unique identifier for the task")
    name: Optional[str] = Field(None, description="Name of the task")
    instruction: str = Field(..., description="Instruction for the task")
    input: Optional[FunctionInput] = Field(None, description="Input for the task")
    output: Optional[FunctionResult] = Field(
        None, description="Output for the task, could be error"
    )
    status: TaskStatus = Field(TaskStatus.PENDING, description="Status of the task")
    sub_tasks: Optional[list["Task"]] = Field(None, description="List of sub-tasks")
    _listeners: List[TaskListener] = []

    def add_listener(self, listener: TaskListener):
        if not hasattr(self, "_listeners") or self._listeners is None:
            self._listeners = []
        self._listeners.append(listener)

    def remove_listener(self, listener: TaskListener):
        if hasattr(self, "_listeners") and listener in self._listeners:
            self._listeners.remove(listener)

    def _notify(self, event: TaskEvent, **kwargs):
        if hasattr(self, "_listeners"):
            for listener in self._listeners:
                listener.on_event(self, event, **kwargs)

    def start(self):
        self.status = TaskStatus.STARTING
        self._notify(TaskEvent.STARTING)

    def run(self):
        self.status = TaskStatus.RUNNING
        self._notify(TaskEvent.RUNNING)

    def complete(self, output: Union[str, BaseModel] = None):
        self.status = TaskStatus.COMPLETED
        self.output = FunctionResult(success=False, output=output)
        self._notify(TaskEvent.COMPLETED)

    def fail(self, reason: str = ""):
        self.status = TaskStatus.FAILED
        self.output = FunctionResult(success=False, error=reason)
        self._notify(TaskEvent.FAILED, reason=reason)

    def add_sub_task(self, task: "Task"):
        """
        Add a sub-task to the task.
        """
        if self.sub_tasks is None:
            self.sub_tasks = []
        self.sub_tasks.append(task)
        self._notify(TaskEvent.SUB_TASK_ADDED, sub_task=task)

    def remove_sub_task(self, task: "Task"):
        """
        Remove a sub-task from the task.
        """
        if self.sub_tasks is not None:
            self.sub_tasks.remove(task)
            self._notify(TaskEvent.SUB_TASK_REMOVED, sub_task=task)

    @classmethod
    def from_instruction(cls, instruction: str, id: Optional[str] = None, **kwargs):
        """
        Create a Task from instruction and optional id. If id is not provided, generate a UUID.
        Additional fields can be passed via kwargs.
        """
        if id is None:
            id = str(uuid.uuid4())
        return cls(id=id, instruction=instruction, **kwargs)
